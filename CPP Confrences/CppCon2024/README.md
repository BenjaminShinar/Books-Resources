<!--
// cSpell:ignore Vectorizing spanny
-->

<link rel="stylesheet" type="text/css" href="../../markdown-style.css">

# CppCon 2024

[Playlist](https://www.youtube.com/playlist?list=PLHTh1InhhwT6U7t1yP2K8AtTEKmcM3XU_), [Schedule](https://cppcon2024.sched.com/#2024-09-15), [Github](https://github.com/CppCon/CppCon2024).

## Topics and Sessions

- Algorithms
- API Design
- Back to Basics
- Concurrency
- Education/Coaching
- Embedded
- Future C++
- GameDev
- Performance
- Robotics and AI
- Scientific Computing
- Software Design
- Tooling
- ISO / WG21
- Open Content

---

- [ ] "Pick a random number... no, not that one!" - Tales of Real-World Exploits Based on Bad Randomness - Max Hoffmann
- [ ] 10 Problems Large Companies Have with Managing C++ Dependencies and How to Solve Them - Augustin Popa
- [ ] A new dragon in the den: fast conversion from floating-point numbers - Cassio Neri
- [ ] A Simple Rollback System in C++: The Secret Behind Online Multiplayer Games - Elias Farhan
- [ ] Advanced and Modern C++ Programming: The Tricky Parts - Nicolai Josuttis
- [ ] Adventures with Legacy CodeBases: Tales of Incremental Improvement - Roth Michaels
- [ ] Another Grab-bag of Oddments - Ben Deane
- [ ] Application of C++ in Computational Cancer Modeling - Ruibo Zhang
- [ ] Author Signing: Andreas Fertig - Andreas Fertig
- [ ] Author Signing: Nicolai Josuttis - Nicolai Josuttis
- [x] Back to Basics: Almost Always Vector? - Kevin Carpenter
- [ ] Back to Basics: Concepts - Nicolai Josuttis
- [ ] Back to Basics: Debugging and Testing - Greg Law, Mike Shah
- [ ] Back to Basics: Function Call Resolution -Ben Saks
- [ ] Back to Basics: Functional Programming in C++ - Jonathan Müller
- [ ] Back to Basics: Generic Programming - David Olsen
- [ ] Back to Basics: Lifetime Management - Phil Nash
- [ ] Back to Basics: Object-Oriented Programming - Andreas Fertig
- [ ] Back to Basics: R-values and Move Semantics - Amir Kirsh
- [ ] Back to Basics: Unit Testing - Dave Steffen
- [ ] Balancing Efficiency and Flexibility: Cost of Abstractions in Embedded Systems - Marcell Juhasz
- [ ] Beyond Compilation Databases to Support C++ Modules: Build Databases - Ben Boeckel
- [ ] Bitcoin Script: Implementation Details and Use Cases - Kris Jusiak
- [ ] Bitcoin: From the White Paper to the World's Reserve Currency - Eduardo Madrid
- [ ] Bitcoin: History and Use Cases - Jon Kalb
- [ ] Bitcoin: Role Playing Bitcoin Based Protocols Including the Lightning Network - Eduardo Madrid
- [ ] Blazing Trails: Building the World's Fastest GameBoy Emulator in Modern C++ - Tom Tesch
- [ ] BoF - GameDev, Growing our Conference Community - Guy Davidson
- [ ] Boosting Software Efficiency: A Case Study of 100% Performance Improvement in an Embedded C++ System - Gili Kamma
- [ ] Bridging the Gap: Writing Portable Programs for CPU and GPU - Thomas Mejstrik
- [ ] Building CppCheck - What We Learned from 17 Years of Development - Daniel Marjamäki
- [ ] Building Safe and Reliable Surgical Robotics with C++ - Milad Khaledyan
- [ ] C++ Exceptions for Smaller Firmware - Khalil Estell
- [ ] C++ Software Design - Klaus Iglberger
- [ ] C++ Templates for Developers - Walter E Brown
- [ ] C++ Under the Hood: Internal Class Mechanisms - Chris Ryan
- [ ] C++/Rust Interop: Using Bridges in Practice - Tyler Weaver
- [ ] C++20 in Practice: A Complete Introduction 2024 - Nicolai Josuttis
- [ ] C++26 Preview - Jeff Garland
- [ ] Can You RVO? Using Return Value Optimization for Performance in Bloomberg C++ CodeBases - Michelle Fae D'Souza
- [ ] Case For Non-Moveable Types - Jason Turner
- [ ] Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics - Paul Gesel
- [ ] Common Package Specification (CPS) in practice: A full round trip implementation in Conan C++ package manager -Diego Rodriguez-Losada Gonzalez
- [ ] Compile-time Validation - Alon Wolf
- [ ] Composing Ancient Mathematical Knowledge Into Powerful Bit-fiddling Techniques - Jamie Pond
- [ ] Contracts for C++ - Timur Doumler
- [ ] Coroutines and Structured Concurrency in Practice - Dmitry Prokoptsev
- [ ] Cpp2/cppFront BoF informal meetup - Neil Henderson
- [ ] Creating a Sender/Receiver HTTP Server - Dietmar Kühl
- [ ] Cross-Platform Determinism Out of the Box - Sherry Ignatchenko
- [ ] Data Is All You Need for Fusion - Manya Bansal
- [ ] Data Structures That Make Video Games Go Round - Al-Afiq Yeong
- [ ] Deciphering C++ Coroutines - Mastering Asynchronous Control Flow - Andreas Weis
- [ ] Deciphering Coroutines - Recap and Prerequisites - Andreas Weis
- [ ] Dependency Injection in C++ : A Practical Guide - Peter Muldoon
- [ ] Design Patterns - The Most Common Misconceptions (2 of N) - Klaus Iglberger
- [ ] Designing a Slimmer Vector of Variants - Christopher Fretz
- [ ] Designing C++ code generator guardrails: A collaboration among outreach and development teams and users - Sherry Sontag, CB Bailey
- [ ] Embracing an Adversarial Mindset for C++ Security - Amanda Rousseau
- [ ] Fast and small C++ - When efficiency matters - Andreas Fertig
- [ ] Gazing Beyond Reflection for C++26 - Daveed Vandevoorde
- [ ] Hidden Overhead of a Function API - Oleksandr Bacherikov
- [ ] Hiding your Implementation Details is Not So Simple - Amir Kirsh
- [ ] High-performance Concurrency in C++ - Fedor Pikus
- [ ] High-performance Cross-platform Architecture: C++ 20 Innovations - Noah Stein
- [ ] High-Performance Numerical Integration in the Age of C++26 - Vincent Reverdy
- [ ] High-performance, Parallel Computer Algebra in C++ - David Tran
- [ ] How Meta Made Debugging Async Code Easier with Coroutines and Senders - Ian Petersen, Jessica Wong
- [ ] Implementing Particle Filters with Ranges - Nahuel Espinosa
- [ ] Implementing Reflection using the new C++20 Tooling Opportunity: Modules - Maiko Steeman
- [ ] import CMake; // Mastering C++ Modules - Bill Hoffman
- [ ] Improving our safety with a quantities and units library - Mateusz Pusz
- [ ] Improving your Team(work) - Callum Piper
- [ ] Interesting Upcoming Features from Low latency, Parallelism and Concurrency from Kona 2023, Tokyo 2024, and St. Louis 2024 - Paul E. McKenney, Maged Michael,Michael Wong
- [ ] Irksome C++ - Walter E Brown
- [ ] Leveraging C++ for Efficient Motion Planning: RRT algorithm for robotic arms - Aditi Pawaskar
- [ ] Leveraging C++20/23 Features for Low Level Interactions - Jeffrey Erickson
- [ ] Limitations and Problems in std::function and Similar Constructs: mitigation and Alternatives - Amandeep Chawla
- [ ] Linear Algebra with The Eigen C++ Library - Daniel Hanson
- [ ] LLVM's Realtime Safety Revolution: Tools for Modern Mission Critical Systems - Christopher Apple, David Trevelyan
- [ ] Making Hard Tests Easy: A Case Study From the Motion Planning Domain - Chip Hogg
- [ ] Many ways to kill an Orc (or a Hero) -Patrice Roy
- [ ] Message Handling with Boolean Algebra -Ben Deane
- [ ] Mix Assertion, Logging, Unit Testing and Fuzzing: Build Safer Modern C++ Application - Xiaofan Sun
- [ ] Modern C++ Error Handling - Phil Nash
- [ ] Modern C++: When Efficiency Matters - Andreas Fertig
- [ ] Monadic Operations in Modern C++: A Practical Approach - Vitaly Fanaskov
- [ ] Multi Producer, Multi Consumer, Lock Free, Atomic Queue - User API and Implementation - Erez Strauss
- [ ] Newer Isn’t Always Better, Investigating Legacy Design Trends and Their Modern Replacements - Katherine Rocha
- [ ] Official ISO C++ WG21 SG meeting of low latency/embedded/games/finance and Machine Learning - Michael Wong
- [ ] Optimizing with Modern C++ - Patrice Roy
- [ ] Peering forward — C++’s next decade - Herb Sutter
- [ ] Performance and Efficiency in C++ for Experts, Future Experts, and Everyone Else - Fedor Pikus
- [ ] Performance engineering - being friendly to your hardware - Ignas Bagdonas
- [ ] Perspectives on Contracts - Lisa Lippincott
- [ ] Ranges++: Are Output Range Adaptors the Next Iteration of C++ Ranges? - Daisy Hollman
- [ ] Reflection based libraries to look forward to - Saksham Sharma
- [ ] Reflection Is Not Contemplation - Andrei Alexandrescu
- [ ] Relocation: Blazing Fast Save And Restore, Then More! - Eduardo Madrid
- [ ] Reusable code, reusable data structures - Sebastian Theophil
- [ ] Safety and Security Panel - Michael Wong, Andreas Weis, Gabriel Dos Reis,Herb Sutter,Lisa Lippincott, Timur Doumler
- [ ] Secrets of C++ Scripting Bindings: Bridging Compile Time and Run Time - Jason Turner
- [ ] Security Beyond Memory Safety - Using Modern C++ to Avoid Vulnerabilities by Design - Max Hoffmann
- [ ] Sender Patterns to Wrangle Concurrency in Embedded Devices - Michael Caisse
- [ ] Session Types in C++: A Programmer's Journey - Miodrag Misha Djukic
- [ ] Shared Libraries and Where To Find Them - Luis Caro Campos
- [ ] So You Think You Can Hash - Victor Ciura
- [ ] spanny 2: rise of std::mdspan - Griswald Brooks
- [ ] Structured Concurrency in C++ - Mateusz Pusz
- [ ] SuperCharge Your IPC Programs With C++20 and CCI Pattern - Arian Ajdari
- [ ] Talk Tech and Keep Your Audience Awake - Andrei Alexandrescu, Sherry Sontag
- [ ] Taming the C++ Filter View - Nicolai Josuttis
- [ ] Techniques to Optimize Multithreaded Data Building During Game Development - Dominik Grabiec
- [ ] Template-less Meta-programming - Kris Jusiak
- [ ] The Beman Project: Bringing Standard Libraries to the Next Level - David Sankel
- [ ] The Most Important Design Guideline is Testability - Jody Hagins
- [ ] The Power of Reducing Variable Scope - Jason Turner
- [ ] This is C++ - Jon Kalb
- [ ] To Int or to Uint, This is the Question - Alex Dathskovsky
- [ ] Tools Every C++ Developer Should Know - Jason Turner
- [ ] Unraveling string_view: Basics, Benefits, and Best Practices - Jasmine Lopez, Prithvi Okade
- [ ] Using Modern C++ to Build XOffsetDataStructure: A Zero-Encoding and Zero-Decoding High-Performance Serialization Library in the Game Industry - Fanchen Su
- [ ] Vectorizing a CFD Code With `std::simd` Supplemented by (Almost) Transparent Loading and Storing - Olaf Krzikalla
- [ ] What Volatile Means (and Doesn’t Mean) - Ben Saks
- [ ] What’s eating my RAM? - Jianfei Pan
- [ ] What’s new for Visual Studio Code: Performance, GitHub Copilot, and CMake Enhancements - Alexandra Kemper, Sinem Akinci
- [ ] What's New in Visual Studio for C++ Developers - Michael Price, Mryam Girmay
- [ ] When Lock-Free Still Isn't Enough: An Introduction to Wait-Free Programming and Concurrency Techniques - Daniel Anderson
- [x] When Nanoseconds Matter: UltraFast Trading Systems in C++ - David Gross - Performance
- [ ] Why is my build so slow? Compilation Profiling and Visualization - Samuel Privett
- [ ] Work Contracts – Rethinking Task Based Concurrency and Parallelism for Low Latency C++ - Michael Maniscalco
- [ ] xstd::any - A New Container for Any Type with Extra Features and Small Object Optimization - Erez Strauss

### When Nanoseconds Matter: UltraFast Trading Systems in C++ - David Gross

<details>
<summary>
Engineering low-level systems and trying to get good performance.
</summary>

[When Nanoseconds Matter: UltraFast Trading Systems in C++](https://youtu.be/sX2nF1fW7kI?si=baUk2_c9e6ZOifLe), [slides](https://github.com/CppCon/CppCon2024/blob/main/Presentations/When_Nanoseconds_Matter.pdf)

Market making, make a lot of small profits and avoid big losses. being fast enough to react and being smart enough to react correctly.

order book: "bids" and "asks", the prices in which others are willing to buy something (a stock), and the prices in which others are selling the same thing. there are hundreds of thousands of price updates per second.

#### Data Structures

our C++ data will look something like:

```cpp
enum class Side {Bid, Ask};

using OrderId = uint64_t;
using Price = uint64_t;
using Volume = uint64_t;

void AddOrder(OrderId orderId, Side side, Price price, Volume volume);
void ModifyOrder(OrderId orderId, Volume newVolume);
void DeleteOrder(OrderId orderId);
```

we definitely would want to use a hashmap, the most obvious choice would be to use <cpp>std::map</cpp> to store the orders, but benchmarking is a bit of a lie, because it has dynamic allocations. so we can make that our first principle - "No node containers".\
So what about <cpp>std::vector</cpp> as the backing container and <cpp>std::lower_bound</cpp>? the complexity is much worse than that of the map, there is a problem that when we modify the top (start) of the vector, we need to copy all the elements afterwards, which is a performance hit. we can get around this by reversing the vector and focusing our actions at the end of it, which reduces the number of copy operations. This is our second principle - "Understanding your problem (by looking at data)".\
the third principle will be "Hand tailored (specialized) algorithms are key to achieve performance".

> Running perf on a benchmark - Can't run perf on the entire binary if our initialization function is "big".

```cpp
void RunPerf()
{
  pid_t pid = fork();
  if (pid == 0)
  {
    const auto parentPid = std::to_string(getppid());
    std::cout << "Running perf on parent process " << parentPid << std::endl;
    execlp("perf", "perf", ..., parentPid.c_str(), (char*)nullptr);
    throw std::runtime_error("execlp failed");
  }
}

void InitAndRunBenchmark()
{
  InitBenchmark(); // might take a long time!
  RunPerf();
  RunBenchmark();
}
```

and then we run `perf stat –I 10000 –M Frontend_Bound,Backend_Bound,Bad_Speculation,Retiring –p pid`, with the `-M` flag being a list of metrics we are interested in, the `-I` is the interval in milliseconds for each report.

some categories (by intel)

- not stalled pipelines
  - retiring
    - base
    - ms-rom
  - bad speculation
    - branch miss-predict
    - machine clear
- stalled pipelines
  - frontend bound
    - fetch latency
    - fetch bandwidth
  - backend bound
    - core bound
    - memory bound

we can also run `perf record -g -p <pid>` to check which instructions take the most time. in our example, it's obvious that the binary search is the problem, and we get a lot of branch miss-predictions. so we try creating a branchless binary-search instead.

```cpp
template <class ForwardIt, class T, class Compare>
ForwardIt branchless_lower_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp)
{
  auto length = last - first;
  while (length > 0)
  {
    auto half = length / 2;
    // multiplication (by 1) is needed for GCC to generate CMOV
    first += comp(first[half], value) * (length - half);
    length = half;
  }
  return first;
}
```

(note: we don't have early exit conditions in the code above).

we can use another tool to check hardware counters, IPCs, branch misses, cycles and instructions. this will show us that our custom code has less prediction misses and more instructions,

we next think about the memory access and hardware, and actually using liner search gives us the most uniform latency. so the fourth principle is "Simplicity is the ultimate sophistication" and the fifth principle is "Mechanical sympathy".

there are also stuff that we could try, but it's hard to measure in vacuum, such as the <cpp>[[likely]]</cpp> and <cpp>[[unlikely]]</cpp> attributes or inlining expressions using lambda functions (IIFE - immediately invoked functions expressions). we should avoid type erasure (<cpp>std::function</cpp>) as it gets in the way of compiler optimizations.

#### Transport: Networking and Concurrency

> General pattern
>
> - Kernel bypass when receiving data from the exchange (or other low-latency signals)
> - Dispatch / fan-out to processes on the same server

in the userspace networking, we can use "SolarFlare" as the industry standard and "OpenOnload" for BSD sockets. we can also have custom TCP/UDP stacks or move even lower to layer2 networking (which will require writing it ourselves). this is our sixth principle - "True efficiency is found not in the layers of complexity we add, but in the unnecessary layers we remove".

we can sometimes replace sockets with shared memory, have as much operations happen away from the kernel.

> Shared Memory\
>
> - If you don't need sockets, no need to pay for their complexity - "As fast as it gets"
> - Kernel isn't involved in any operations
> - Multi processes requires it – which is good for minimizing operational risk
>
> What works well in shared memory
>
> - Contiguous blocks of data: arrays!
> - One writer, one or multiple readers -> stay away from multiple writers

| Metric              | Concurrent Queues                    |
| ------------------- | ------------------------------------ |
| Bounded             | Yes – simpler & faster               |
| Blocking            | No – readers don't affect the writer |
| Number of Consumers | Many                                 |
| Message Size        | Variable length                      |
| Dispatch            | Fan-out                              |
| Type Support        | PODs                                 |

the seventh principle is "Choose the right tool for the right task", so lets design our queue: "FastQueue".

two counters (pointers) - read and write counters. when we write data, we first move the write counter, copy the data, and move the read counter to the same location. when there are no writes in place, the two counters are at the same place.

```cpp
struct QProducer
{
  void Write(std::span<std::byte> buffer);
};

struct QConsumer
{
  int32_t TryRead(std::span<std::byte> buffer); // returns #bytes read, 0 if nothing to read
};

// simplified code!
void QProducer::Write(std::span<std::byte> buffer)
{
  const int32_t payloadSize = sizeof(int32_t) + buffer.size(); 
  mLocalCounter += payloadSize; // advance the write counter
  mQ->mWriteCounter.store(mLocalCounter, std::memory_order_release);
  std::memcpy(mNextElement, &size, sizeof(int32_t));
  std::memcpy(mNextElement + sizeof(int32_t), buffer.data(), buffer.size());
  mQ->mReadCounter.store(mLocalCounter, std::memory_order_release);
  mNextElement += payloadSize; // advance the read counter
}

int32_t QConsumer::TryRead(std::span<std::byte> buffer)
{
  if (mLocalCounter == mQ->mReadCounter.load(std::memory_order_acquire))
  {
    return 0; // nothing to read
  }

  int32_t size;
  std::memcpy(&size, mNextElement, sizeof(int32_t)); // data race
  int32_t writeCounter = mQ->mWriteCounter.load(std::memory_order_acquire);
  EXPECT(writeCounter – mLocalCounter <= QUEUE_SIZE, "queue overflow");
  EXPECT(size <= buffer.size(), "buffer space isn’t large enough");
  std::memcpy(buffer.data(), mNextElement + sizeof(size), size); // data race
  const int32_t payloadSize = sizeof(size) + size;
  mLocalCounter += payloadSize;
  mNextElement += payloadSize;
  writeCounter = mQ->mWriteCounter.load(std::memory_order_acquire);
  EXPECT(writeCounter– mLocalCounter <= QUEUE_SIZE, "queue overflow");
}
```

we have a data race situation, <cpp>std::memcpy</cpp> is not atomic. the performance is ok, but not great, so we try to make it better.

first, we try to avoid moving the write-counter every time.

```cpp
void QProducer::Write(std::span<std::byte> buffer)
{
  const int32_t payloadSize = sizeof(int32_t) + buffer.size(); 
  mLocalCounter += payloadSize;
  // we "reserve" more space (X% of the total queue) 
  // to avoid touching this cache line on every message written
  if (mCachedWriteCounter < mLocalCounter)
  {
    mCachedWriteCounter = Align<Q_WRITE_COUNTER_BLOCK_BYTES>(mLocalCounter);
    mQ->mWriterCounter.store(mCachedWriteCounter, std::memory_order_release);
  }
  std::memcpy(mNextElement, &size, sizeof(int32_t));
  std::memcpy(mNextElement + sizeof(int32_t), buffer.data(), buffer.size());
  mQ->mReadCounter.store(mLocalCounter, std::memory_order_release);
  mNextElement += payloadSize;
}
```

next, we try and optimize the data alignment

```cpp
void QProducer::Write(std::span<std::byte> buffer)
{
  const int32_t payloadSize = sizeof(int32_t) + Align<Q_BLOCK_ALIGNMENT>(buffer.size()); 
  mLocalCounter += payloadSize;
  // ...
}
```

and caching the read counter

```cpp
int32_t QConsumer::TryRead(std::span<std::byte> buffer)
{
  // we might already know from the previous read counter that more data is available, and
  // in this case we avoid reading this cache line for no reason
  if (mLocalReadCounter == mCachedReadCounter)
  {
    mCachedReadCounter = mQ->mReadCounter.load(std::memory_order_acquire);
  }

  if (mLocalReadCounter == mCachedReadCounter)
  {
    return 0;
  }
  // ...
}
```

another option is to avoid copies, serialize the data directly into the queue. this is an API change.

#### Measurements

measurements are intrusive, and add overhead to performance. we don't know in advance where the bottleneck will be. we can use simple scoped measurements, or have some instrumentation framework. but we also need audits and alerts on the data we gather. this is the eighth principle - "Being fast is good - staying fast is better".

"Thinking about the system as a whole" is the ninth principle.

#### Summary - Principles

1. No node containers.
2. Understanding your problem (by looking at data).
3. Hand tailored (specialized) algorithms are key to achieve performance.
4. Simplicity is the ultimate sophistication.
5. Mechanical sympathy.
6. True efficiency is found not in the layers of complexity we add, but in the unnecessary layers we remove.
7. Choose the right tool for the right task.
8. Being fast is good - staying fast is better.
9. Thinking about the system as a whole.

</details>
